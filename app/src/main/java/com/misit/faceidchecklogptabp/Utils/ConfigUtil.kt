package com.misit.faceidchecklogptabp.Utilsimport android.app.*import android.app.job.JobInfoimport android.app.job.JobSchedulerimport android.content.*import android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.media.RingtoneManagerimport android.net.ConnectivityManagerimport android.net.NetworkCapabilitiesimport android.net.Uriimport android.os.Buildimport android.provider.MediaStoreimport android.util.Logimport android.view.Viewimport android.view.Windowimport android.view.WindowManagerimport android.widget.*import androidx.appcompat.app.AlertDialogimport androidx.core.app.NotificationCompatimport androidx.core.content.ContextCompatimport androidx.localbroadcastmanager.content.LocalBroadcastManagerimport com.bumptech.glide.Glideimport com.google.android.material.textfield.TextInputEditTextimport com.misit.faceidchecklogptabp.Rimport com.misit.faceidchecklogptabp.services.JobServicesimport kotlinx.coroutines.GlobalScopeimport kotlinx.coroutines.launchimport org.joda.time.LocalDateimport org.joda.time.format.DateTimeFormatimport org.joda.time.format.DateTimeFormatterimport retrofit2.Callimport retrofit2.Callbackimport retrofit2.Responseimport java.io.*import java.lang.Exceptionimport java.net.HttpURLConnectionimport java.net.URLimport java.text.SimpleDateFormatimport java.util.*object ConfigUtil {    var builder : AlertDialog.Builder?=null    var dialog : AlertDialog?=null    lateinit var notificationManager: NotificationManager    lateinit var notifBuilder : NotificationCompat.Builder    fun dMY(tanggal: String):String{        val fmt: DateTimeFormatter = DateTimeFormat.forPattern("d MMMM, yyyy")        return LocalDate.parse(tanggal).toString(fmt)    }    fun resultIntent(activity: Activity){        val intent = Intent()        activity.setResult(Activity.RESULT_OK, intent)        activity.finish()    }    fun streamFoto(bitmap: Bitmap, file: File):File{        try {            // Get the file output stream            val stream: OutputStream = FileOutputStream(file)            //var uri = Uri.parse(file.absolutePath)            // Compress bitmap            bitmap!!.compress(Bitmap.CompressFormat.JPEG, 30, stream)            // Flush the stream            stream.flush()            // Close stream            stream.close()        } catch (e: IOException){ // Catch the exception            e.printStackTrace()        }        return file    }    fun streamFotoCorutine(bitmap: Bitmap, file: File):File{        GlobalScope.launch {            try {                // Get the file output stream                val stream: OutputStream = FileOutputStream(file)                //var uri = Uri.parse(file.absolutePath)                // Compress bitmap                bitmap!!.compress(Bitmap.CompressFormat.JPEG, 30, stream)                // Flush the stream                stream.flush()                // Close stream                stream.close()            } catch (e: IOException){ // Catch the exception                e.printStackTrace()            }        }        return file    }    //    DIALOG TANGGAL    fun showDialogTgl(inTgl: TextInputEditText, c: Context) {        val now = Calendar.getInstance()        val datePicker =            DatePickerDialog.OnDateSetListener { view: DatePicker?, year: Int, month: Int, dayOfMonth: Int ->                now.set(Calendar.YEAR, year)                now.set(Calendar.MONTH, month)                now.set(Calendar.DAY_OF_MONTH, dayOfMonth)                inTgl.setText(SimpleDateFormat("dd MMMM yyyy", Locale.US).format(now.time))            }        DatePickerDialog(            c,            datePicker,            now.get(Calendar.YEAR),            now.get(Calendar.MONTH),            now.get(Calendar.DAY_OF_MONTH)        ).show()    }    //    DIALOG TANGGAL    //    DIALOG JAM    fun showDialogTime(inTime: TextInputEditText, c: Context) {        val now = Calendar.getInstance()        val timePicker = TimePickerDialog.OnTimeSetListener { timePicker, hour, minute: Int ->            now.set(Calendar.HOUR_OF_DAY, hour)            now.set(Calendar.MINUTE, minute)            inTime.setText(SimpleDateFormat("HH:mm", Locale.US).format(now.time))        }        TimePickerDialog(            c,            timePicker,            now.get(Calendar.HOUR_OF_DAY),            now.get(Calendar.MINUTE),            true        ).show()    }//    DIALOG JAM    // Method to save an bitmap to a file    fun bitmapToFile(bitmap: Bitmap, applicationContext: Context): Uri {        // Get the context wrapper        val wrapper = ContextWrapper(applicationContext)        // Initialize a new file instance to save bitmap object        var file = wrapper.getDir("Images", Context.MODE_PRIVATE)        file = File(file, "${UUID.randomUUID()}.jpg")        try{            // Compress the bitmap and save in jpg format            val stream:OutputStream = FileOutputStream(file)            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream)            stream.flush()            stream.close()        }catch (e: IOException){            e.printStackTrace()        }        // Return the saved bitmap uri        return Uri.fromFile(File(file.absolutePath))    }    // Method to save an bitmap to a file//    Save File    fun saveFile(bitmap: Bitmap, c: Context,dir:String,fileName: String): Uri {        // Get the context wrapper        val dir = c.getExternalFilesDir(dir)        // Initialize a new file instance to save bitmap object        val file = File(dir, fileName)        try{            // Compress the bitmap and save in jpg format            val stream:OutputStream = FileOutputStream(file)            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream)            stream.flush()            stream.close()        }catch (e: IOException){            e.printStackTrace()        }        // Return the saved bitmap uri        return Uri.fromFile(File(file.absolutePath))    }//    Save File    fun downloadFile(bitmap: Bitmap,fileName:String, applicationContext: Context,dir:String): Uri {        var file = applicationContext.getExternalFilesDir(dir)        file = File(file, "${fileName}.jpg")        try{            // Compress the bitmap and save in jpg format            val stream:OutputStream = FileOutputStream(file)            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream)            stream.flush()            stream.close()        }catch (e: IOException){            e.printStackTrace()        }        // Return the saved bitmap uri        return Uri.fromFile(File(file.absolutePath))    }    fun createFolder(c: Context,folderName:String){        var file = File(c.getExternalFilesDir(null), folderName)        if (file.exists()){            Log.d("File_Dir", "Sudah Ada Dir")        }else{            file.mkdirs()            if(file.isDirectory){                Log.d("File_Dir", "Dir Berhasil Di Buat")            }else{                Log.d("File_Dir", "Dir Gagal Dibuat")            }        }    }    fun deleteInABPIMAGES(c: Context,dir:String):Boolean {        var children:Array<String>?=null        var dir = File(c.getExternalFilesDir(null), dir)        var z = 0        if (dir.isDirectory) {            children = dir.list()            for (i in children.indices) {                File(dir, children[i]).delete()                z++            }        }        if(z==children?.size){            return true        }else{            return false        }    }    fun getBitmapFromURL(src: String?): Bitmap? {        return try {            val url = URL(src)            val connection: HttpURLConnection = url.openConnection() as HttpURLConnection            connection.setDoInput(true)            connection.connect()            val input: InputStream = connection.getInputStream()            BitmapFactory.decodeStream(input)        } catch (e: IOException) {            // Log exception            null        }    }    fun cekKoneksi(context: Context):Boolean{        var result = false        val connectivityManager =            context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            val networkCapabilities = connectivityManager.activeNetwork ?: return false            val actNw =                connectivityManager.getNetworkCapabilities(networkCapabilities) ?: return false            result = when {                actNw.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -> true                actNw.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -> true                actNw.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) -> true                else -> false            }        } else {            connectivityManager.run {                connectivityManager.activeNetworkInfo?.run {                    result = when (type) {                        ConnectivityManager.TYPE_WIFI -> true                        ConnectivityManager.TYPE_MOBILE -> true                        ConnectivityManager.TYPE_ETHERNET -> true                        else -> false                    }                }            }        }        return result    }    fun koneksiInActive(c: Activity){        AlertDialog.Builder(c)            .setTitle("Maaf Koneksi Internet Tidak Ada!")            .setPositiveButton("OK, Keluar", { dialog,                                               which ->                c.finish()            }).show()    }    fun playNotificationSound(c:Context,method:String) {        try {            val defSoundURI = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)            val r = RingtoneManager.getRingtone(c,defSoundURI)            if(method=="Play"){                r.play()            }else if(method=="Stop"){                r.stop()            }        }catch (e: Exception){            Log.d("ER_Ringtone",e.toString())        }    }    fun isMyServiceRunning(mClass: Class<*>, c: Context): Boolean {        val manager: ActivityManager = c.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager        for (service: ActivityManager.RunningServiceInfo in manager.getRunningServices(Integer.MAX_VALUE)){            if(mClass.name.equals(service.service.className)){                return true            }        }        return false    }    fun startStopService(        jvClass: Class<*>,        c: Context,        USERNAME: String,        tokenPassingReceiver: BroadcastReceiver    ) {        if(isMyServiceRunning(jvClass, c)){            LocalBroadcastManager.getInstance(c).unregisterReceiver(tokenPassingReceiver)            var intent = Intent(c, jvClass).apply {                this.action = Constants.SERVICE_STOP            }            c.stopService(intent)            Log.d("ServiceName", "${jvClass} Stop")        }else{            var intent = Intent(c, jvClass).apply {                this.action = Constants.SERVICE_START            }            intent.putExtra("username", USERNAME)            c.startService(intent)            Log.d("ServiceName", "${jvClass} Start")        }    }    fun showLoading(c: Context,activity: Activity, title: String,pesan:String, option: String){        builder = AlertDialog.Builder(c)        var layout = activity.layoutInflater.inflate(R.layout.custom_loading, null)        var titleDialog = layout.findViewById<View>(R.id.tvTitleDialog) as TextView        var circle = layout.findViewById<View>(R.id.circleProgress) as ProgressBar        var imgLoading = layout.findViewById<View>(R.id.abpLoading) as ImageView        var pesanDialog = layout.findViewById<View>(R.id.pesanDialog) as TextView        titleDialog.text = title        Glide.with(c).load(R.drawable.abp).into(imgLoading)        if(option=="circle"){            circle.visibility = View.VISIBLE            pesanDialog.visibility = View.GONE            imgLoading.visibility = View.GONE        }else if(option=="abp"){            circle.visibility = View.GONE            pesanDialog.visibility = View.GONE            imgLoading.visibility = View.VISIBLE        }else if(option=="text"){            imgLoading.visibility = View.GONE            circle.visibility = View.GONE            pesanDialog.visibility = View.VISIBLE            pesanDialog.text = pesan        }        builder?.setView(layout)        builder?.setCancelable(false)        dialog = builder?.show()    }    fun dismisLoading(){        if (dialog != null) {            dialog?.dismiss()            dialog = null        }    }    fun jobScheduler(c:Context,scheduler: JobScheduler?){        val componentName = ComponentName(c, JobServices::class.java)        val jobInfo = JobInfo.Builder(Constants.JOB_SERVICE_ID,componentName)            .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)            .setPersisted(true)            .setPeriodic(900000,10)            .build()        val resultCode = scheduler?.schedule(jobInfo)        if(resultCode == JobScheduler.RESULT_SUCCESS){            Log.d("JobScheduler","Job Scheduled")        }else{            Log.d("JobScheduler","Job Scheduled Failed")        }    }    fun isJobServiceOn(context: Context, JOB_ID: Int): Boolean {        val scheduler = context.getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler        var hasBeenScheduled = false        for (jobInfo in scheduler.allPendingJobs) {            if (jobInfo.id == JOB_ID) {                hasBeenScheduled = true                break            }        }        return hasBeenScheduled    }    fun showNotification(c: Context,title: String?, body: String?,intent: Intent,requestCode:Int,notifName:String) {        var pendingIntent = PendingIntent.getActivity(c,requestCode,intent, PendingIntent.FLAG_UPDATE_CURRENT)        var dSoundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)        notificationManager = c.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager        if(Build.VERSION.SDK_INT>= Build.VERSION_CODES.O){            var oChannel = NotificationChannel(notifName,title, NotificationManager.IMPORTANCE_HIGH)            oChannel.enableVibration(true)            oChannel.enableLights(true)            notificationManager.createNotificationChannel(oChannel)            notifBuilder = NotificationCompat.Builder(c,notifName)                .setSmallIcon(R.drawable.abp_white)                .setColor(R.drawable.abp_blue)                .setContentTitle(title)                .setContentText(body)                .setSound(dSoundUri)                .setAutoCancel(true)                .setGroup(notifName)                .setPriority(NotificationCompat.PRIORITY_HIGH)                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)                .setStyle(NotificationCompat.BigTextStyle().bigText(body))                .setContentIntent(pendingIntent)        }else{            notifBuilder = NotificationCompat.Builder(c,notifName)                .setSmallIcon(R.drawable.abp_white)                .setColor(R.drawable.abp_blue)                .setContentTitle(title)                .setContentText(body)                .setGroup(notifName)                .setPriority(NotificationCompat.PRIORITY_HIGH)                .setAutoCancel(true)                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)                .setSound(dSoundUri)                .setStyle(NotificationCompat.BigTextStyle().bigText(body))                .setContentIntent(pendingIntent)        }        var idRand = (0 until 100).random()        notificationManager.notify(idRand,notifBuilder.build())    }}